Subject: Re: openGl
Date: Wed, 01 May 2002 21:57:02 -0400
From: "Vince Scheib" <scheib@cs.unc.edu>

They all end up making the perspective matrix.. there's just different
ways to do the math.

Ok, here's the deal: In GL, there are three matrices:
GL_MODELVIEW
GL_PROJECTION
GL_TEXTURE

Forget about the Texture one for now.

The standard convention is to modify the projection matrix very seldomly
(usually only when the window is resized) and always leave the modelview
active.

The projection will take care of the field of view and the near and far
values (BTW, always just make far REALLY far.. like FLT_MAX/2 or
something. You barely loose any precision in the z-buffer from doing so
and it's nicer to work with).

On every frame, LoadIdentity to your modelview to reset it.
Then do whatever your camera work is.
Then do any transformations to move objects around.

When setting up your camera, if gluLookat isn't your thing, go ahead and
use Roll Pitch Yaw. Those are so easy no one built a function to make
them easier.

RPY is just a serious of rotations around orthogonal axis (IE, xyz). The
order matters, of course.

In GL, people usually use the "math"-ish way to think of the
coordinates: x is horizontal, y is up, and z points backwards. Think of
being up at the chalk board. z is backwards because people almost always
use right handed systems. z is coming out of the board at you.

glTranslatef(pos,.,.);
glRotatef(roll ,0,0,1);
glRotatef(pitch,1,0,0);
glRotatef(yaw  ,0,1,0);

is one way. With RPY, however, you need to think about what you really
want. This is how I think of a series of transformations. I think of
having a little set of axis, and for each transformation I move it. Each
subsequent transformation moves _relative_ to the little axis that I'm
keeping track of.

So, with RPY, let's say you have an airplane. Roll 90 degrees (so it
tilted left, by convention). Ok, now Pitch -90 (so it heads downwards).

But wait, the plane is now facing down the x axis, not facing straight
down. (because, once it rolled, it's local coordinates changed).

You can imagine that this may not be what you want if you had a flight
simulator (try the above but with only 45 degrees at a time, hold
something in front of you when you do it.)

Ok, now try

glTranslatef(pos,.,.);
glRotatef(yaw  ,0,1,0);
glRotatef(pitch,1,0,0);
glRotatef(roll ,0,0,1);

was this what you wanted? very likely if you are talking about an
airplane.

Well, I'll let you untangle what you want. Did you not like the way I
thought out how to place the object? There's another way:

Read the transformation in reverse order. Always make the transformation
happen with respect to the world co-ordinates.

Getting a knack for this (if you haven't yet) is a good thing, 2D
examples help, and so does holding things in front of you and making
funny noises.

Lots of people find the gluLookat very handy, because they know exactly
which way they want their object to point.. and generally want up to be
up.

There's some good tutorials here you should look at:
http://www.xmission.com/~nate/tutors.html

ciao,

--
Vincent Scheib <<><>> http://www.scheib.net/
